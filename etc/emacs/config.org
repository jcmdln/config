# -*- mode : org -*-
#+TITLE: My literate GNU / Emacs configuration
#+STARTUP: indent
#+LANGUAGE: en

After years of maintaining my GNU/Emacs configuration using various
methods, I wanted something that was easier to share with others. The
better method, in my opinion, is to use an org-mode configuration which
is what is defined in this document. Rather than using abrupt comments
to keep the total number of lines low, fully explaining what settings I
use has proved to be much more helpful when assisting others.

I do _NOT_ recommend directly using this configuration unless you are
especially lazy. I suggest that you review this configuration and add
what functionality you desire to your own so that you do not experience
unexpected behavior.


* About
This configuration works by using init.el to load config.org if it has
not already been converted to a config.el file, and byte-compiling to
create config.elc which will be implicitly loaded on startup. Should
config.org be updated and the file be newer than config.el the
configuration will be regenerated and byte-compiled on startup.

While I see this as a bit convoluted, it allows me to have a literate
configuration without requiring that I load org-mode on every init. I
know that many suggest starting emacs as a daemon as a way of
mitigating long startup times, I prefer that this is kept to a minimum
by default.


* Startup
This section comprises the things we will want to occur as soon as
possible, preferably before or during init.

** Encoding
Here we will attempt to enforce using utf-8 encoding by default. While
this may not be very important for general usage, I much prefer this
behavior.

#+begin_src emacs-lisp
(setq prefer-coding-system       'utf-8
      set-default-coding-systems 'utf-8
      set-language-environment   "UTF-8"
      set-locale-environment     "en_US.UTF-8")
#+end_src

** Environment
Emacs already inherits much of what is currently in the system's
environment, though here we'll ensure that this is occurring. We will
modify our environment slightly so that the current Emacs session is
our default editor, which is mainly useful for git/magit.

#+begin_src emacs-lisp
(setenv "EDITOR"         "emacsclient")
(setenv "GIT_EDITOR"     "emacsclient")
(setenv "MANPATH"        (getenv "MANPATH"))
(setenv "PATH"           (getenv "PATH"))
(setenv "PROMPT_COMMAND" "")
(setenv "SHELL"          (getenv "SHELL"))
(setenv "TERM"           (getenv "TERM"))
#+end_src

** Garbage Collection
Emacs has some considerations for older and more memory restricted
systems in terms of how the garbage collector is configured. I've seen
some suggest not making adjustments to the garbage collector, though
since I only use Emacs on modern systems with a lot of available memory
I don't mind if Emacs is slightly more wasteful.

I am fully aware that this is me simply "chasing the dragon" of init
time, though there are some other implications that will be explained.

*** gc-cons-percentage
For the purposes of initialization, we will also increase
gc-cons-percentage which means that until reaching 60% of the current
heap size, GC will not occur. After init completes we will set this to
15%, though the default is 10%.

#+begin_src emacs-lisp
(setq gc-cons-percentage 0.80)

(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-percentage 0.10)))
#+end_src

*** gc-cons-threshold
Increasing the gc-cons-threshold, which is the number of bytes of
storage that must be allocated for Lisp objects after one garbage
collection in order to trigger another garbage collection. On 32-bit
systems, this is 400kb and on 64-bit systems this is 800kb. Specifying
a larger value will mean that garbage collection will occur less often.

We'll set this value to 2mb globally, which will more than halve the
total number of GC pauses we experience while not drastically
increasing the amount of time needed for GC to complete.

#+begin_src emacs-lisp
(setq gc-cons-threshold  (* 2 1024 1024))
#+end_src

** Custom Configuration
This is probably not in the appropriate section though all custom
configuration should be in it's own file rather than being dumped into
init.el messily.

#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+end_src

** Appearance
In terms of appearance, I prefer to have as little wasted space and
visual clutter while using built-in themes.

*** Toolbars
Prevent tool bars from ever being initialized. We do this by defining
toolbars as "disabled" so that when they are called after init, they are
never loaded.

#+begin_src emacs-lisp
(when (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
#+end_src

*** Theme
I don't care for using third-party themes, and think that tango-dark is
more than adequate. We will load the built-in tango-dark theme and use
the default Monospace system font. I used to adjust the font size and
line spacing but the same behavior may be achieved by adjusting your
system defaults.

#+begin_src emacs-lisp
(load-theme 'tango-dark)
(set-face-attribute :family "Noto Mono")
#+end_src

Next we'll adjust some settings to improve editing files.

#+begin_src emacs-lisp
(setq column-number-mode    t
      require-final-newline t
      show-paren-delay      0.0
      visible-bell          nil)

(show-paren-mode t)
#+end_src

*** Extras
This part is a bit unorganized though reduces clutter by inhibiting
buffers and adjusting how Emacs' clipboard works.

#+begin_src emacs-lisp
(setq initial-scratch-message             ""
      inhibit-splash-screen               t
      inhibit-startup-buffer-menu         t

      mouse-yank-at-point                 t
      save-interprogram-paste-before-kill t
      select-enable-primary               nil)
#+end_src


* Input
I do make some minor changes to input methods, though I intend to remain
as faithful to "the Emacs way" as I can.

** Keyboard
In terms of keyboard input, I only make slight adjustments though their
usefulness is highly subjective.

*** Scrolling
I prefer scrolling to behave more like other editors, where the cursor
reaches the final line before scrolling and the cursor scrolls one line
at a time. This does cause emacs to use additional resources, though I
prefer this behavior to the default.

#+begin_src emacs-lisp
(setq auto-window-vscroll             nil
      scroll-conservatively           101
      scroll-margin                   0
      scroll-preserve-screen-position 1
      scroll-step                     1
      scroll-up-aggressively          0.0
      scroll-down-aggressively        0.0)
#+end_src

*** Custom Keybinds
From my time of using tmux + vim I had grown to prefer some custom
keybinds I made for handling splits or navigating through panes. Here
I've attempted to recreated the subjective ease of navigation I prefer:

#+begin_src emacs-lisp
(global-set-key (kbd "M--")
                (lambda()
                  (interactive)
                  (split-window-vertically)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))

(global-set-key (kbd "M-=")
                (lambda()
                  (interactive)
                  (split-window-horizontally)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))

(global-set-key (kbd "<M-down>")  'windmove-down)
(global-set-key (kbd "<M-left>")  'windmove-left)
(global-set-key (kbd "<M-right>") 'windmove-right)
(global-set-key (kbd "<M-up>")    'windmove-up)

(global-set-key (kbd "C-c c")     'comment-or-uncomment-region)
#+end_src

** Mouse
In terms of the mouse, I really only adjust scrolling behavior and add
xterm support:

#+begin_src emacs-lisp
(setq mouse-wheel-follow-mouse      't
      mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount     '(1 ((shift) . 1))
      xterm-mouse-mode              t)

(global-set-key (kbd "<mouse-4>")
                (lambda() (interactive) (scroll-down-line 3)))
(global-set-key (kbd "<mouse-5>")
                (lambda() (interactive) (scroll-up-line 3)))
#+end_src


* Package Management
In this section, we will configure the package manager to be a bit,
well, more intelligent.

First, let's require that it's loaded before we proceed:

#+begin_src emacs-lisp
(require 'package)
#+end_src

Now we'll define where packages should be installed to, then add the
archives we want to download packages from. We then set the priority
from highest to lowest based on our preference, though to clarify
further if a package exists in multiple sources, it will prefer
installing the package from the archive defined with the HIGHEST
priority. We'll then initialize package before moving on.

#+begin_src emacs-lisp
(setq package-user-dir "~/.emacs.d/pkg/"
      package-archives
      '(("GNU ELPA"     . "http://elpa.gnu.org/packages/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/"))
      package-archive-priorities
      '(("GNU ELPA"     . 1)
        ("MELPA Stable" . 2)
        ("MELPA"        . 0)))

(package-initialize)
#+end_src

Now we'll check if use-package has been installed, refresh our package
contents (ie list of known installable packages) before installing
use-package if it was missing.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+end_src

Here we'll require that use-package and bind-key are loaded AFTER they
have been byte-compiled, which will be used for loading packages and
their configurations later.

#+begin_src emacs-lisp
(eval-when-compile
  (require 'use-package)
  (require 'bind-key))
#+end_src

Before we move on, we'll make use-package have some ideal default
behaviors:
- Packages are not loaded unless called by bind, hook, or demand
- Packages are always installed if not present
- Confirm packages exist before loading configurations

#+begin_src emacs-lisp
(setq use-package-always-defer      t
      use-package-always-ensure     t
      use-package-check-before-init t)
#+end_src

Next we'll ensure that we have a clean folder hierarchy for our
configuration by using no-littering:

#+begin_src emacs-lisp
(use-package no-littering
  :demand t

  :config
  (setq-local auto-save-file-name-transforms
              `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src


* Packages
In this section we will define our packages and their respective
configurations, organized around their purpose into top-level sections.

** Built-ins
These are packages that Emacs currently ships with.

*** eshell
The default configuration of eshell is, well, bad. The ordinary user who
opens it once and considers it to be a bad tool is missing out of the
full potential eshell provides. I've spent a _lot_ of time making eshell
behave and look like typical unix shells, so maybe try it for yourself.

#+begin_src emacs-lisp
(use-package eshell
  :config
  (setq eshell-banner-message             "")
  (setq eshell-cmpl-cycle-completions     nil)
  (setq eshell-error-if-no-glob           t)
  (setq eshell-hist-ignoredups            t)
  (setq eshell-history-size               4096)
  (setq eshell-prefer-lisp-functions      t)
  (setq eshell-save-history-on-exit       t)
  (setq eshell-scroll-to-bottom-on-input  nil)
  (setq eshell-scroll-to-bottom-on-output nil)
  (setq eshell-scroll-show-maximum-output nil)
  (setq eshell-prompt-regexp              "^[^#$\n]*[#$] ")

  (setq eshell-prompt-function
        (lambda nil
          (concat "[" (user-login-name) "@"
                  (substring (car (split-string (system-name) "\\."))) " "
                  (if (string= (eshell/pwd) (getenv "HOME"))
                      "~" (eshell/basename (eshell/pwd))) "]"
                  (if (= (user-uid) 0) "# " "$ "))))

  (setq eshell-visual-commands
        '("alsamixer" "atop" "htop" "less" "mosh" "nano" "ssh"
          "tail" "top" "vi" "vim" "watch"))

  (defun eshell/clear()
    (interactive)
    (recenter 0))

  (defun eshell-new()
    "Open a new instance of eshell."
    (interactive)
    (eshell 'N)))
#+end_src

*** eww
I like eww, but it was missing a few things for me to use it as my
primary browser for non-interactive sites. Here we will ensure that eww
is our primary browser when visiting links, and that images are blocked
by default. Should you have multiple eww buffers open and want to
toggle displaying images in a specific buffer, you may now do so.

#+begin_src emacs-lisp
(use-package eww
  :init
  (setq browse-url-browser-function 'eww-browse-url)

  :config
  (setq shr-blocked-images "")

  (defun eww-toggle-images()
    "Toggle blocking images in eww."
    (interactive)
    (if (bound-and-true-p shr-blocked-images)
        (setq-local shr-blocked-images nil)
      (setq-local shr-blocked-images ""))
    (eww-reload))

  (defun eww-new()
    "Open a new instance of eww."
    (interactive)
    (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
      (switch-to-buffer (generate-new-buffer "*eww*"))
      (eww-mode)
      (eww url))))

(use-package eww-lnum
  :after (eww)

  :init
  (add-hook 'eww-mode-hook
            (lambda()
              (define-key eww-mode-map "f" 'eww-lnum-follow)
              (define-key eww-mode-map "F" 'eww-lnum-universal))))
#+end_src

*** gnus
I've bounced between using "real" email clients and gnus quite a few
times, though here we will attempt to make gnus behave like other
clients.

#+begin_src emacs-lisp
(use-package gnus
  :bind
  (("<M-down>" . windmove-down)
   ("<M-up>"   . windmove-up))

  :init
  (add-hook 'gnus-summary-hook   'gnus-summary-sort-by-most-recent-date)

  :config
  (setq gnus-sum-thread-tree-false-root        "")
  (setq gnus-sum-thread-tree-indent            "  ")
  (setq gnus-sum-thread-tree-leaf-with-other   "├─> ")
  (setq gnus-sum-thread-tree-root              "")
  (setq gnus-sum-thread-tree-single-leaf       "╰─> ")
  (setq gnus-sum-thread-tree-vertical          "│ ")

  (setq gnus-summary-line-format               "%U%R:%-15,15o  %-15,15f  %B%S\n")
  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)
  (setq gnus-thread-sort-functions             '(gnus-thread-sort-by-date))

  (if (file-exists-p "~/.emacs.d/usr/gnus.el")
      (load-file     "~/.emacs.d/usr/gnus.el")))
#+end_src

*** ibuffer
I'm not a fan of the default ibuffer behavior, if the total size of this
section does not make that clear. Here we will sort buffers, show human
readable sizes, and define a ton of filter groups.

#+begin_src emacs-lisp
(use-package ibuffer
  :bind
  (("C-x C-b"         . ibuffer)
   ("<C-tab>"         . next-buffer)
   ("<C-iso-lefttab>" . previous-buffer))

  :init
  (add-hook 'ibuffer-hook      'ibuffer-auto-mode)
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-alphabetic)
  (add-hook 'ibuffer-auto-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  :config
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))

  (setq ibuffer-show-empty-filter-groups nil)

  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("emacs"
                  (or (name . "^\\*scratch\\*$")
                      (name . "^\\*Messages\\*$")
                      (name . "^\\*Completions\\*$")
                      (name . "^\\*Compile-Log\\*")
                      (name . "^\\*Customize\\*")
                      (name . "^\\*Help\\*$")
                      (name . "^\\*Disabled Command\\*$")
                      (mode . dired-mode)))

                 ("circe"
                  (or (mode . circe-mode)
                      (mode . circe-channel-mode)
                      (mode . circe-server-mode)))

                 ("clang"  (name . "^\\*clang-"))
                 ("dev"    (name . "^\\*RTags\\*$"))
                 ("elfeed" (name . "^\\*elfeed"))
                 ("eshell" (mode . eshell-mode))
                 ("eww"    (name . "^\\*eww\\*"))

                 ("fly"
                  (or (name . "^\\*Flycheck")
                      (name . "^\\*Flyspell")))

                 ("gnus"
                  (or (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))

                 ("magit"
                  (or (name . "magit")
                      (name . "COMMIT_EDITMSG")))

                 ("man"
                  (or (name . "^\\*Man ")
                      (name . "^\\*WoMan")))))))

  (setq ibuffer-formats
        '((mark modified read-only " "
                (name 35 35 :left :nil) " "
                (size-h 9 -1 :right) " "
                (mode 16 16 :left :elide) " "
                filename-and-process))))
#+end_src

*** scratch
I like opening multiple scratch buffers, so I added a function to allow
me to make a new numbered scratch buffer.

#+begin_src emacs-lisp
(use-package scratch
  :init
  (defun scratch-new()
    "Open a new scratch buffer."
    (interactive)
    (switch-to-buffer (generate-new-buffer "*scratch*"))
    (lisp-mode)))
#+end_src

*** server
I feel that Emacs is missing some extensions for server-based functions
and added a warning when attempting to close Emacs. Also, if you want to
update your packages or kill Emacs without saving in a quicker fashion
you may appreciate the additional functions.

#+begin_src emacs-lisp
(use-package server
  :bind
  ("C-x C-c" . server-stop)

  :init
  (unless (and (fboundp 'server-running-p)
               (server-running-p))
    (server-start))

  :config
  (defun server-kill()
    "Delete current Emacs server, then kill Emacs"
    (interactive)
    (if (y-or-n-p "Kill Emacs without saving? ")
        (kill-emacs)))

  (defun server-stop()
    "Prompt to save buffers, then kill Emacs."
    (interactive)
    (if (y-or-n-p "Quit Emacs? ")
        (save-buffers-kill-emacs)))

  (defun server-update()
    "Refresh package contents, then update all packages."
    (interactive)
    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))
    (package-utils-upgrade-all)))
#+end_src

** Essentials
This section contains packages that integrate well with emacs while
extending the default behaviors. These packages, much like the title
implies, are essential for me.

*** async
#+begin_src emacs-lisp
(use-package async
  :config
  (async-bytecomp-package-mode '(all)))
#+end_src

*** auto-compile
#+begin_src emacs-lisp
(use-package auto-compile
  :config
  (auto-compile-on-load-mode)
  (auto-compile-on-save-mode))
#+end_src

*** counsel
#+begin_src emacs-lisp
(use-package counsel
  :bind
  (("<f1> f"  . counsel-describe-function)
   ("<f1> l"  . counsel-find-library)
   ("<f1> v"  . counsel-describe-variable)
   ("<f2> i"  . counsel-info-lookup-symbol)
   ("<f2> u"  . counsel-unicode-char)
   ("C-s"     . counsel-grep-or-swiper)
   ("C-S-o"   . counsel-rhythmbox)
   ("C-c g"   . counsel-git)
   ("C-c j"   . counsel-git-grep)
   ("C-c l"   . counsel-ag)
   ("C-r"     . counsel-minibuffer-history)
   ("C-x C-f" . counsel-find-file)
   ("C-x l"   . counsel-locate)
   ("M-x"     . counsel-M-x)))

(use-package counsel-etags
  :init
  (add-hook 'c-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))

  (add-hook 'c++-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))

  :config
  (setq-local large-file-warning-threshold nil)
  (setq-local tags-revert-without-query    t))

(use-package swiper
  :demand t)
#+end_src

*** flyspell
#+begin_src emacs-lisp
(use-package flyspell
  :init
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'prog-mode-hook     'flyspell-prog-mode)
  (add-hook 'text-mode-hook     'flyspell-mode))
#+end_src

*** ivy
#+begin_src emacs-lisp
(use-package ivy
  :bind
  (("C-c C-r" . ivy-resume)
   ("<f6>"    . ivy-resume))

  :init
  (ivy-mode 1)

  :config
  (setq ivy-use-virtual-buffers      t)
  (setq enable-recursive-minibuffers t))
#+end_src

*** package-utils
#+begin_src emacs-lisp
(use-package package-utils
  :demand t)
#+end_src

*** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :demand t

  :init
  (add-hook 'markdown-mode-hook 'smartparens-mode)
  (add-hook 'prog-mode-hook     'smartparens-mode)
  (add-hook 'text-mode-hook     'smartparens-mode)

  :config
  (setq sp-highlight-pair-overlay     nil)
  (setq sp-highlight-wrap-overlay     nil)
  (setq sp-highlight-wrap-tag-overlay nil))
#+end_src

*** undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :demand t

  :config
  (global-undo-tree-mode))
#+end_src

*** xclip
#+begin_src emacs-lisp
(use-package xclip
  :init
  (xclip-mode 1))
#+end_src

** Development
This section contains packages that are primarily used for development.
If you aren't using Emacs for development, this section will not be very
useful for you.

Before we continue to individual packages, first we'll change some
default behaviors so that tabs aren't used, trailing whitespace is
deleted, and on save all tabs are replaced with spaces.

#+begin_src emacs-lisp
(setq indent-tabs-mode nil)

(add-hook 'before-save-hook
          (lambda()
            (delete-trailing-whitespace)
            (if (not indent-tabs-mode)
                (untabify (point-min) (point-max)))))
#+end_src

*** clang-format
#+begin_src emacs-lisp
(use-package clang-format)
#+end_src

*** company
#+begin_src emacs-lisp
(use-package company
  :init
  (add-hook 'lisp-mode-hook 'company-mode)
  (add-hook 'prog-mode-hook 'company-mode)
  (add-hook 'text-mode-hook 'company-mode)

  :config
  (setq company-tooltip-limit  20)
  (setq company-idle-delay     0.3)
  (setq company-echo-delay     0)
  (setq company-begin-commands '(self-insert-command)))

(use-package company-ansible
  :after (company ansible-vault))

(use-package company-emoji
  :after (company))

(use-package company-irony
  :after (company irony)

  :config
  (add-to-list 'company-backends 'company-irony))

(use-package company-irony-c-headers
  :after (company irony company-irony)

  :config
  (add-to-list 'company-backends '(company-irony-c-headers company-irony)))

(use-package company-shell
  :after (company))

(use-package company-web
  :after (company))
#+end_src

*** diff-hl
#+begin_src emacs-lisp
(use-package diff-hl
  :init
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'text-mode-hook 'diff-hl-mode))
#+end_src

*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :demand t

  :init
  (add-hook 'prog-mode-hook 'flycheck-mode))

(use-package flycheck-inline
  :demand t

  :init
  (add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))
#+end_src

*** gist
#+begin_src emacs-lisp
(use-package gist)
#+end_src

*** highlight-indent-guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :demand t

  :init
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)

  :config
  (setq highlight-indent-guides-method 'character))
#+end_src

*** irony
At some point I'll explain what I've done here, because it was rather
annoying to get right.

#+begin_src emacs-lisp
(use-package irony
  :init
  (defun my-irony-mode ()
    (when (memq major-mode '(c-mode c++-mode objc-mode))
      (irony-mode 1)))

  (add-hook 'c-mode-hook     'my-irony-mode)
  (add-hook 'c++-mode-hook   'my-irony-mode)
  (add-hook 'objc-mode       'my-irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  :config
  (define-key irony-mode-map [remap completion-at-point] 'counsel-irony)
  (define-key irony-mode-map [remap complete-symbol]     'counsel-irony))
#+end_src

*** languages
This section is gross, and due for a rewrite to explain things a bit
better.

#+begin_src emacs-lisp
(add-hook 'lisp-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(global-visual-line-mode t)
#+end_src

#+begin_src emacs-lisp
(add-hook 'c-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))
            (setq-local c-default-style  "cc-mode")
            (setq-local c-set-style      "linux")
            (setq-local c-basic-offset   4)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        4)))
#+end_src

#+begin_src emacs-lisp
(add-hook 'c++-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
            (setq-local c-default-style  "ellemtel")
            (setq-local c-set-style      "ellemtel")
            (setq-local c-basic-offset   4)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        4)))
#+end_src

#+begin_src emacs-lisp
(add-hook 'js-mode-hook
          (lambda()
            (setq-local js-indent-level 2)
            (setq-local tab-width       2)))
#+end_src

#+begin_src emacs-lisp
(add-hook 'lisp-mode-hook
          (lambda()
            (setq-local c-basic-offset 2)
            (setq-local tab-width      2)))
#+end_src

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (add-hook 'org-metaup-hook    'windmove-up)
            (add-hook 'org-metaleft-hook  'windmove-left)
            (add-hook 'org-metadown-hook  'windmove-down)
            (add-hook 'org-metaright-hook 'windmove-right)

            (setq-local org-support-shift-select 'always)))
#+end_src

#+begin_src emacs-lisp
(use-package ahk-mode)
(use-package android-mode)
(use-package angular-mode)
(use-package ansible-vault)
(use-package apache-mode)
(use-package caddyfile-mode)
#+end_src

#+begin_src emacs-lisp
(use-package clojure-mode
  :init
  (add-hook 'clojure-mode-hook 'flycheck-clojure))

(use-package flycheck-clojure)
#+end_src

#+begin_src emacs-lisp
(use-package cmake-mode)
(use-package coffee-mode)
(use-package csharp-mode)
(use-package cuda-mode)
(use-package d-mode)
(use-package dart-mode)
(use-package docker-compose-mode)
(use-package dockerfile-mode)
(use-package dotenv-mode)
(use-package es-mode)
(use-package gdscript-mode)
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+end_src

#+begin_src emacs-lisp
;;go get -u -v \
;;   github.com/go-delve/delve/cmd/dlv \
;;   github.com/jstemmer/gotags \
;;   github.com/mdempsky/gocode \
;;   github.com/rogpeppe/godef \
;;   golang.org/x/lint/golint \
;;   golang.org/x/tools/cmd/goimports \
;;   golang.org/x/tools/cmd/gorename \
;;   golang.org/x/tools/cmd/guru

(use-package go-mode
  :init
  (add-hook 'before-save-hook 'gofmt-before-save)
  (add-hook 'go-mode-hook
            (lambda()
              (setq-local tab-width        4)
              (setq-local indent-tabs-mode t)
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode t))))

(use-package go-eldoc
  :after (go-mode)
  :init
  (add-hook 'go-mode-hook 'go-eldoc-setup))

(use-package golint
  :after (go-mode))

(use-package company-go
  :after (company go-mode))
#+end_src

#+begin_src emacs-lisp
(use-package gradle-mode)
(use-package json-mode)
(use-package less-css-mode)
(use-package lua-mode)
(use-package markdown-mode)
(use-package markdown-preview-mode)
(use-package meson-mode)
(use-package nginx-mode)
(use-package ninja-mode)
(use-package npm-mode)
#+end_src

#+begin_src emacs-lisp
(use-package php-mode)

(use-package company-php
  :after (company php-mode))
#+end_src

#+begin_src emacs-lisp
(use-package protobuf-mode)
(use-package qml-mode)
(use-package racket-mode)
#+end_src

#+begin_src emacs-lisp
(use-package rjsx-mode
  :init
  (add-to-list 'auto-mode-alist
               '("components\\/.*\\.js\\'" . rjsx-mode))

  (add-hook 'rjsx-mode
            (lambda()
              (setq-local js-indent-level 2)
              (setq-local tab-width       2))))
#+end_src

#+begin_src emacs-lisp
(use-package rust-mode)
(use-package sass-mode)
(use-package swift-mode)
(use-package systemd)
(use-package typescript-mode)
(use-package vue-mode)
(use-package yaml-mode)
#+end_src

*** magit
#+begin_src emacs-lisp
(use-package magit
  :demand t

  :bind
  ("C-c C-c" . with-editor-finish))
#+end_src

*** rainbow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :demand t

  :init
  (add-hook 'markdown-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'prog-mode-hook     'rainbow-delimiters-mode)
  (add-hook 'text-mode-hook     'rainbow-delimiters-mode))
#+end_src

*** realgud
#+begin_src emacs-lisp
(use-package realgud)
#+end_src

*** rtags
#+begin_src emacs-lisp
(use-package rtags
  :init
  (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
  (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
  (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)

  :config
  (setq-local rtags-autostart-diagnostics         t)
  (setq-local rtags-completions-enabled           t)
  (setq-local rtags-display-result-backend        'ivy)
  (setq-local flycheck-highlighting-mode          nil)
  (setq-local flycheck-check-syntax-automatically nil)
  (rtags-diagnostics))

(use-package ivy-rtags
  :config
  (setq rtags-display-result-backend 'ivy))

(use-package company-rtags
  :after (company)

  :config
  (push 'company-rtags company-backends))

(use-package flycheck-rtags
  :after (rtags flycheck)

  :config
  (add-hook 'prog-mode-hook 'flycheck-mode))
#+end_src


** Extras
This section contains additional applications or packages that I
suspect others wouldn't use, though I use these rather heavily.

*** auto-dictionary
#+begin_src emacs-lisp
(use-package auto-dictionary
  :config
  (add-hook 'flyspell-mode-hook (auto-dictionary-mode 1)))
#+end_src

*** circe
#+begin_src emacs-lisp
(use-package circe
  :init
  (add-hook 'circe-message-option-functions 'my-circe-message-option-chanserv)
  (add-hook 'circe-chat-mode-hook
            (lambda()
              (lui-set-prompt
               (concat (propertize (concat (buffer-name) ":")
                                   'face 'circe-prompt-face) " "))))
  (add-hook 'lui-mode-hook
            (lambda()
              (setq fringes-outside-margins t)
              (setq left-margin-width       9)
              (setq word-wrap               t)
              (setq wrap-prefix             "")))

  :config
  (defun my-circe-message-option-chanserv (nick user host command args)
    (when (and (string= "ChanServ" nick)
               (string-match "^\\[#.+?\\]" (cadr args)))
      '((dont-display . t))))

  (setq circe-default-part-message "")
  (setq circe-default-quit-message "")
  (setq circe-format-server-topic  "*** Topic: {userhost}: {topic-diff}")
  (setq circe-reduce-lurker-spam   t)
  (setq circe-use-cycle-completion t)
  (setq lui-fill-type              nil)
  (setq lui-flyspell-alist         '((".*" "american")))
  (setq lui-flyspell-p             t)
  (setq lui-logging-directory      "~/.emacs.d/var/circe")
  (setq lui-time-stamp-format      "%H:%M:%S")
  (setq lui-time-stamp-position    'left-margin)

  (load "lui-logging" nil t)
  (enable-lui-logging-globally)
  (require 'circe-chanop)
  (enable-circe-color-nicks)
  (setf (cdr (assoc 'continuation fringe-indicator-alist)) nil)

  (if (file-exists-p "~/.emacs.d/usr/circe.el")
      (load-file     "~/.emacs.d/usr/circe.el")))
#+end_src

*** define-word
#+begin_src emacs-lisp
(use-package define-word)
#+end_src

*** dimmer
#+begin_src emacs-lisp
(use-package dimmer
  :init
  (add-hook 'after-init-hook 'dimmer-mode))
#+end_src

*** elfeed
#+begin_src emacs-lisp
(use-package elfeed
  :bind
  ("C-x w" . elfeed)

  :config
  (setq-local elfeed-search-filter "@1-week-ago +unread ")
  (setq-local url-queue-timeout    30)

  (if (file-exists-p "~/.emacs.d/usr/elfeed.el")
      (load-file     "~/.emacs.d/usr/elfeed.el")))
#+end_src

*** helpful
#+begin_src emacs-lisp
(use-package helpful)
#+end_src

*** nov
#+begin_src emacs-lisp
(use-package nov
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src

*** pdf-tools
This package allows viewing PDF's within Emacs, though in order to use
this package you must install the required dependencies and compile the
package as outlined in the following url:

https://github.com/politza/pdf-tools#installation

#+begin_src emacs-lisp
(use-package pdf-tools
  :demand t)
#+end_src

*** ranger
#+begin_src emacs-lisp
(use-package ranger
  :init
  (ranger-override-dired-mode t))
#+end_src
