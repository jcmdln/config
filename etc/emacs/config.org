# -*- mode : org -*-
#+TITLE: My literate Emacs configuration
#+SUBTITLE: A blend of org-mode, use-package, and too many packages.
#+STARTUP: indent
#+LANGUAGE: en

This singular file is meant to represent my personal GNU/Emacs
configuration.  It all started when I saw a [[https://www.youtube.com/watch?v=dljNabciEGg][video]] by Howard Abrams that
was shared in #emacs on Freenode which really got me into the whole
idea of using org-mode to manage my configuration.

My goals for using org-mode to manage my configuration are as follows:
- Use Org-Mode to provide contextual information, (almost) always
- Preserve core GNU/Emacs functionality, though enhance it when desired
- Leverage use-package for replicability
- Initialization time is a reasonable concern

* Warnings
Before we get too far, keep in mind that this file represents my
personal workflow.  I have made many changes to how Emacs functions.

I would suggest that you use the contents of this file as a reference
for your own configuration, as you may otherwise experience unexpected
behavior.

* Usage
This file may be used to fully replicate my setup, and acts as both
documentation as well as configuration.  There are two strategies you
may choose from to deploy this configuration:

1. Use Emacs to evaluate this file via command line:

#+BEGIN_SRC shell
emacs --eval='(org-babel-load-file "~/.emacs.d/config.org")'
#+END_SRC

2. Configure Emacs by loading this file

#+BEGIN_SRC emacs-lisp
M-x org-babel-load-file RET ~/.emacs.d/config.org
#+END_SRC

* Files
To make the most effective use of the various startup files that Emacs
will check for, each file listed in this section will detail the
configurations that they contain.

** init.el
Emacs will look for this specific file once it reaches the
initialization phase.  Here we will make modifications to things that
ship with Emacs and should be changed early.

*** Garbage Collection
Emacs has some considerations for older and more memory restricted
systems in terms of how the garbage collector is configured.  On systems
with restrictive amounts of memory, you may want to adjust or remove
these changes.

**** gc-cons-percentage
For the purposes of initialization, we'll increase `gc-cons-percentage`
to defer garbage collection.  The settings below mean that garbage
collection is deferred until reaching 80% of the heap size.  After init
completes, we restore the default value.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq gc-cons-percentage-default gc-cons-percentage
      gc-cons-percentage         0.80)

(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-percentage gc-cons-percentage-default)))
#+END_SRC

**** gc-cons-threshold
Now we will increase the `gc-cons-threshold`, which referrs to the
total bytes of storage for lisp objects that must be allocated to
trigger subsequent garbage collections.

On 32-bit systems this threshold is 400KB, while on 64-bit systems it
is 800KB.  The idea is that by specifying a larger theshold, garbage
collection will occur less often, meaning fewer GC pauses.

We'll set this value to 4MB globally, which will significantly reduce
the total number of GC pauses we experience.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq gc-cons-threshold-default gc-cons-threshold
      gc-cons-threshold         (* 4 1024 1024))
#+END_SRC

*** Handling Custom Configuration
Specify our `custom-file` so that our generated configuration files
won't have a configuration block uncleanly appended to them:

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq custom-file "~/.emacs.d/custom.el")
#+END_SRC

*** Encoding
Here we will attempt to enforce using utf-8 encoding:

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq prefer-coding-system       'utf-8
      set-default-coding-systems 'utf-8
      set-language-environment   "UTF-8"
      set-locale-environment     "en_US.UTF-8")
#+END_SRC

*** Environment
Emacs already inherits much of what is currently in the system's
environment, though here we'll modify our environment slightly so that
the current Emacs session is our default editor, and disable
PROMPT_COMMAND which might cause problems with ssh connections:

#+BEGIN_SRC emacs-lisp :tangle init.el
(setenv "EDITOR"         "emacsclient")
(setenv "GIT_EDITOR"     "emacsclient")
(setenv "MANPATH"        (getenv "MANPATH"))
(setenv "PATH"           (getenv "PATH"))
(setenv "PROMPT_COMMAND" "")
(setenv "SHELL"          (getenv "SHELL"))
(setenv "TERM"           (getenv "TERM"))
#+END_SRC

*** Appearance
In terms of appearance, I prefer to have as little wasted space and
visual clutter while using built-in themes.

**** Disable toolbars
I don't find the toolbars to be useful.  The following will disable the
various toolbars when their functions are bound, which prevents them
from ever loading or being fully initialized:

#+BEGIN_SRC emacs-lisp :tangle init.el
(when (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
#+END_SRC

**** Disable startup buffers and actions

Disable the various buffers and actions that occur post-init, other
than showing an empty scratch buffer:

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq initial-scratch-message     ""
      inhibit-splash-screen       t
      inhibit-startup-buffer-menu t)
#+END_SRC

**** Re-use frames rather than creating new ones
One big annoyance is Emacs arbitrary splitting my window to show a
newly created buffer.  This is especially annoying when I run a command
myself such as man which distorts my

Enforce always re-using the currently selected frame when a new buffer
is opened or focused.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq pop-up-frames               nil
      pop-up-windows              nil
      display-buffer-reuse-frames t)

(setq Man-notify-method 'pushy)
#+END_SRC

**** Set a basic theme and font
Tango-Dark, a monospace font, what else do you need?

#+BEGIN_SRC emacs-lisp :tangle init.el
(load-theme 'tango-dark)
(set-face-attribute :family "Monospace")
#+END_SRC

**** Improve editing generic files
At the very least, I like to see the column number, ensure that \n
always preceeds EOF, tweak the paren matching delay, and disable the
visual bell:

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq column-number-mode    t
      require-final-newline t
      show-paren-delay      0.2
      visible-bell          nil)

(show-paren-mode t)
#+END_SRC

**** Remove trailing whitespace on save

#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Bootstrap config.el
On init, ensure that the generated config files are always newer than
this file.  By doing so, we only have to make edits to this file and
the changes will cause our configuration to be regenerated.

#+BEGIN_SRC emacs-lisp :tangle init.el
(defun emacs-reconfig()
  "Build and compile 'org-mode' config."
  (interactive)
  (require 'org)
  (org-babel-load-file "~/.emacs.d/config.org")
  (byte-compile-file   "~/.emacs.d/config.el"))

(if (file-newer-than-file-p "~/.emacs.d/config.org"
                            "~/.emacs.d/config.el")
    (emacs-reconfig)
  (load "~/.emacs.d/config.el"))
#+END_SRC

** config.el
Emacs won't be looking for this file itself, though our init.el will
load this file which contains changes we want to make post-init.

*** Package Management
Package management isn't loaded by default, so we have to explicitly
require it be loaded now:

#+BEGIN_SRC emacs-lisp :tangle config.el
(require 'package)
#+END_SRC

There was a bug in the Emacs 26.x release that caused errors when
attempting to retrieve the package list from elpa that requires this
workaround, though it probably isn't needed anymore:

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"
      package-check-signature nil)
#+END_SRC

Here we're defining where to put packages, where we should get packages
from, and the priority we should retrive packages if a package with the
same name exists on multiple sources.

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq package-user-dir "~/.emacs.d/pkg/"
      package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/"))
      package-archive-priorities
      '(("GNU ELPA"     . 3)
        ("MELPA Stable" . 2)
        ("MELPA"        . 1)))
#+END_SRC

With the above changes made, we can now initialize the package module:

#+BEGIN_SRC emacs-lisp :tangle config.el
(package-initialize)
#+END_SRC

**** use-package
The first pacakge we'll ensure exists is use-package, which the rest of
this file relies on for handling per-package configuration.  In newer
versions of Emacs use-package is now a built-in, but we should check to
be nice to older versions:

#+BEGIN_SRC emacs-lisp :tangle config.el
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package)
  (require 'bind-key))
#+END_SRC

Some decent use-package tweaks are to defer loading a package unless
demanded, ensure a package exists or can be retrieved before loading
its configuration, and check that use-package is installed and active
before attempting to initialize:

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq use-package-always-defer      t
      use-package-always-ensure     t
      use-package-check-before-init t)
#+END_SRC

***** no-littering
The second package will keep our ~/.emacs.d nice and tidy by adjusting
the locations of configuration files.  It uses a unix-y format, which
is a nice change.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package no-littering
  :demand t
  :config
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+END_SRC

*** Input
I do make some minor changes to input methods, though I intend to remain
as faithful to "the Emacs way" as I can.

**** Keyboard
In terms of keyboard input, I only make slight adjustments though their
usefulness is highly subjective.

****** Keybinds
From my time of using tmux + vim I had grown to prefer some custom
keybinds I made for handling splits or navigating through panes. Here
I've attempted to recreated the subjective ease of navigation I prefer:

#+BEGIN_SRC emacs-lisp :tangle config.el
(global-set-key (kbd "M--")
                (lambda()
                  (interactive)
                  (split-window-vertically)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))

(global-set-key (kbd "M-=")
                (lambda()
                  (interactive)
                  (split-window-horizontally)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(global-set-key (kbd "<M-down>")  'windmove-down)
(global-set-key (kbd "<M-left>")  'windmove-left)
(global-set-key (kbd "<M-right>") 'windmove-right)
(global-set-key (kbd "<M-up>")    'windmove-up)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(global-set-key (kbd "C-c c")     'comment-or-uncomment-region)
#+END_SRC

**** Mouse
In terms of the mouse, I really only adjust scrolling behavior and add
xterm support:

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq mouse-wheel-follow-mouse      't
      mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount     '(1 ((shift) . 1)))

(add-hook 'after-init-hook
          (lambda()
            (xterm-mouse-mode 1)))

(global-set-key (kbd "<mouse-4>")
                (lambda()
                  (interactive)
                  (scroll-down-line 3)))

(global-set-key (kbd "<mouse-5>")
                (lambda()
                  (interactive)
                  (scroll-up-line 3)))
#+END_SRC

**** Scrolling
I prefer scrolling to behave more like other editors, where the cursor
reaches the final line before scrolling and the cursor scrolls one line
at a time. This does cause emacs to use additional resources, though I
prefer this behavior to the default.

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq auto-window-vscroll             nil
      scroll-conservatively           101
      scroll-margin                   0
      scroll-preserve-screen-position 1
      scroll-step                     1
      scroll-up-aggressively          0.0
      scroll-down-aggressively        0.0)
#+END_SRC

**** Misc
This part is a bit unorganized though reduces clutter by inhibiting
buffers and adjusting how Emacs' clipboard works.

#+BEGIN_SRC emacs-lisp :tangle config.el
(setq mouse-yank-at-point                 t
      save-interprogram-paste-before-kill t
      select-enable-primary               nil)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-to-list 'display-buffer-alist
             '("*Help*" display-buffer-same-window))

(add-to-list 'display-buffer-alist
             '("*Man*" display-buffer-same-window))
#+END_SRC
*** Built-ins
These are packages that Emacs currently ships with.

**** eshell
The default configuration of eshell is, well, bad. The ordinary user who
opens it once and considers it to be a bad tool is missing out of the
full potential eshell provides. I've spent a _lot_ of time making eshell
behave and look like typical unix shells, so maybe try it for yourself.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package eshell
  :config
  (setq eshell-banner-message             ""
        eshell-cmpl-cycle-completions     nil
        eshell-error-if-no-glob           t
        eshell-hist-ignoredups            t
        eshell-history-size               4096
        eshell-prefer-lisp-functions      t
        eshell-save-history-on-exit       t
        eshell-scroll-to-bottom-on-input  nil
        eshell-scroll-to-bottom-on-output nil
        eshell-scroll-show-maximum-output nil
        eshell-prompt-regexp              "^[^#$\n]*[#$] ")

  (setq eshell-prompt-function
        (lambda nil
          (concat "[" (user-login-name) "@"
                  (car (split-string (system-name) "\\.")) " "
                  (if (string= (eshell/pwd) (getenv "HOME"))
                      "~" (eshell/basename (eshell/pwd))) "]"
                  (if (= (user-uid) 0) "# " "$ "))))

  (setq eshell-visual-commands
        '("alsamixer" "atop" "htop" "less" "mosh" "nano" "ssh"
          "tail" "top" "vi" "vim" "watch"))

  (defun eshell/clear()
    "Hide previous scrollback to provide a clear view."
    (interactive)
    (recenter 0))

  (defun eshell-new()
    "Open a new instance of eshell."
    (interactive)
    (eshell 'N)))
#+END_SRC

**** eww
I like eww, but it was missing a few things for me to use it as my
primary browser for non-interactive sites. Here we will ensure that eww
is our primary browser when visiting links, and that images are blocked
by default. Should you have multiple eww buffers open and want to
toggle displaying images in a specific buffer, you may now do so.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package eww
  :init
  (setq browse-url-browser-function 'eww-browse-url)

  :config
  (setq shr-blocked-images "")

  (defun eww-toggle-images()
    "Toggle blocking images in eww."
    (interactive)
    (if (bound-and-true-p shr-blocked-images)
        (setq-local shr-blocked-images nil)
      (setq-local shr-blocked-images ""))
    (eww-reload))

  (defun eww-new()
    "Open a new instance of eww."
    (interactive)
    (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
      (switch-to-buffer (generate-new-buffer "*eww*"))
      (eww-mode)
      (eww url))))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package eww-lnum
  :after (eww)
  :init
  (add-hook 'eww-mode-hook
            (lambda()
              (define-key eww-mode-map "f" 'eww-lnum-follow)
              (define-key eww-mode-map "F" 'eww-lnum-universal))))
#+END_SRC

**** gnus
I've bounced between using "real" email clients and gnus quite a few
times, though here we will attempt to make gnus behave like other
clients.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package gnus
  :bind
  (("<M-down>" . windmove-down)
   ("<M-up>"   . windmove-up))

  :init
  (add-hook 'gnus-summary-prepared-hook 'gnus-summary-sort-by-most-recent-date)

  :config
  (setq gnus-show-threads                      t
        gnus-sum-thread-tree-false-root        ""
        gnus-sum-thread-tree-indent            "  "
        gnus-sum-thread-tree-leaf-with-other   "├─> "
        gnus-sum-thread-tree-root              ""
        gnus-sum-thread-tree-single-leaf       "╰─> "
        gnus-sum-thread-tree-vertical          "│ "
        gnus-summary-line-format               "%U%R:%-15,15o  %-20,20A  %B%s\n"
        gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
        gnus-thread-hide-subtree               t
        gnus-thread-sort-functions             '(gnus-thread-sort-by-date))

  (if (file-exists-p "~/.emacs.d/usr/gnus.el")
      (load-file     "~/.emacs.d/usr/gnus.el")))
#+END_SRC

**** ibuffer
I'm not a fan of the default ibuffer behavior, if the total size of this
section does not make that clear. Here we will sort buffers, show human
readable sizes, and define a ton of filter groups.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ibuffer
  :bind
  (("C-x C-b"         . ibuffer)
   ("<C-tab>"         . next-buffer)
   ("<C-iso-lefttab>" . previous-buffer))

  :init
  (add-hook 'ibuffer-hook      'ibuffer-auto-mode)
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-alphabetic)
  (add-hook 'ibuffer-auto-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  :config
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))

  (setq ibuffer-show-empty-filter-groups nil)

  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("exwm"
                  (mode . exwm-mode))

                 ("emacs"
                  (or (name . "^\\*scratch\\*$")
                      (name . "^\\*Messages\\*$")
                      (name . "^\\*Help\\*$")
                      (name . "^\\*Completions\\*$")
                      (name . "^\\*Compile-Log\\*")
                      (name . "^\\*Customize\\*")
                      (name . "^\\*Disabled Command\\*$")))

                 ("apps"
                  (or (mode . dired-mode)
                      (mode . eshell-mode)))

                 ("mail"
                  (or (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))

                 ("feed"
                  (or (mode . eww-mode)
                      (name . "^\\*elfeed")))

                 ("irc"
                  (or (mode . circe-mode)
                      (mode . circe-channel-mode)
                      (mode . circe-server-mode)))

                 ("dev"
                  (or (name . "^\\*clang")
                      (name . "^\\*gcc")
                      (name . "^\\*RTags")
                      (name . "^\\*rdm\\*")
                      (name . "magit")
                      (name . "COMMIT_EDITMSG")
                      (name . "^\\*Flycheck")
                      (name . "^\\*Flyspell")))

                 ("docs"
                  (or (name . "^\\*Man ")
                      (name . "^\\*WoMan")
                      (mode . pdf-view-mode)))))))

  (setq ibuffer-formats
        '((mark modified read-only " "
                (name 35 35 :left :nil) " "
                (size-h 9 -1 :right) " "
                (mode 16 16 :left :elide) " "
                filename-and-process))))
#+END_SRC

**** scratch
I like opening multiple scratch buffers, so I added a function to allow
me to make a new numbered scratch buffer.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package scratch
  :init
  (defun scratch-new()
    "Open a new scratch buffer."
    (interactive)
    (switch-to-buffer (generate-new-buffer "*scratch*"))
    (lisp-mode)))
#+END_SRC

**** server
I feel that Emacs is missing some extensions for server-based functions
and added a warning when attempting to close Emacs. Also, if you want to
update your packages or kill Emacs without saving in a quicker fashion
you may appreciate the additional functions.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package server
  :bind ("C-x C-c" . server-stop)
  :init
  (unless (and (fboundp 'server-running-p)
               (server-running-p))
    (server-start))

  :config
  (defun server-kill()
    "Delete current Emacs server, then kill Emacs"
    (interactive)
    (if (y-or-n-p "Kill Emacs without saving? ")
        (kill-emacs)))

  (defun server-stop()
    "Prompt to save buffers, then kill Emacs."
    (interactive)
    (if (y-or-n-p "Quit Emacs? ")
        (save-buffers-kill-emacs)))

  (defun server-update()
    "Refresh package contents, then update all packages."
    (interactive)
    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))
    (package-utils-upgrade-all)))
#+END_SRC

*** Essentials
This section contains packages that integrate well with emacs while
extending the default behaviors. These packages, much like the title
implies, are essential for me.

**** async
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package async
  :config
  (async-bytecomp-package-mode '(all)))
#+END_SRC

**** auto-compile
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package auto-compile
  :config
  (auto-compile-on-load-mode)
  (auto-compile-on-save-mode))
#+END_SRC

**** counsel
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package counsel
  :bind
  (("<f1> f"  . counsel-describe-function)
   ("<f1> l"  . counsel-find-library)
   ("<f1> v"  . counsel-describe-variable)
   ("<f2> i"  . counsel-info-lookup-symbol)
   ("<f2> u"  . counsel-unicode-char)
   ("C-s"     . counsel-grep-or-swiper)
   ("C-S-o"   . counsel-rhythmbox)
   ("C-c g"   . counsel-git)
   ("C-c j"   . counsel-git-grep)
   ("C-c l"   . counsel-ag)
   ("C-r"     . counsel-minibuffer-history)
   ("C-x C-f" . counsel-find-file)
   ("C-x l"   . counsel-locate)
   ("M-x"     . counsel-M-x)))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package counsel-etags
  :init
  (add-hook 'c-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))
  (add-hook 'c++-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))

  :config
  (setq-local large-file-warning-threshold nil)
  (setq-local tags-revert-without-query    t))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package swiper
  :demand t)
#+END_SRC

**** flyspell
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flyspell
  :init
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'prog-mode-hook     'flyspell-prog-mode)
  (add-hook 'text-mode-hook     'flyspell-mode))
#+END_SRC

**** ivy
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ivy
  :bind
  (("C-c C-r" . ivy-resume)
   ("<f6>"    . ivy-resume))

  :init
  (ivy-mode 1)

  :config
  (setq ivy-use-virtual-buffers      t
        enable-recursive-minibuffers t))
#+END_SRC

**** package-utils
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package package-utils
  :demand t)
#+END_SRC

**** smartparens
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package smartparens
  :demand t
  :init
  (add-hook 'markdown-mode-hook 'smartparens-mode)
  (add-hook 'prog-mode-hook     'smartparens-mode)
  (add-hook 'text-mode-hook     'smartparens-mode)

  :config
  (setq sp-highlight-pair-overlay     nil
        sp-highlight-wrap-overlay     nil
        sp-highlight-wrap-tag-overlay nil))
#+END_SRC

**** undo-tree
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package undo-tree
  :demand t
  :config
  (global-undo-tree-mode))
#+END_SRC

**** xclip
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package xclip
  :init
  (xclip-mode 1))
#+END_SRC


*** Development
**** Utilities
***** clang-format
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package clang-format
  :disabled)
#+END_SRC

***** company
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company
  :init
  (add-hook 'lisp-mode-hook 'company-mode)
  (add-hook 'prog-mode-hook 'company-mode)
  (add-hook 'text-mode-hook 'company-mode)

  :config
  (setq company-tooltip-limit  20
        company-idle-delay     0.3
        company-echo-delay     0
        company-begin-commands '(self-insert-command)))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-emoji
  :disabled
  :after (company))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-shell
  :disabled
  :after (company))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-web
  :disabled
  :after (company))
#+END_SRC

***** diff-hl
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package diff-hl
  :init
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'text-mode-hook 'diff-hl-mode))
#+END_SRC

***** flycheck
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flycheck
  :demand t
  :init
  (add-hook 'prog-mode-hook 'flycheck-mode))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flycheck-inline
  :demand t
  :init
  (add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))
#+END_SRC

***** gist
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package gist)
#+END_SRC

***** highlight-indent-guides
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package highlight-indent-guides
  :demand t
  :init
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)

  :config
  (setq highlight-indent-guides-method 'character))
#+END_SRC

***** irony
At some point I'll explain what I've done here, because it was rather
annoying to get right.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package irony
  :init
  (defun my-irony-mode ()
    (when (memq major-mode '(c-mode c++-mode objc-mode))
      (irony-mode 1)))

  (add-hook 'c-mode-hook     'my-irony-mode)
  (add-hook 'c++-mode-hook   'my-irony-mode)
  (add-hook 'objc-mode       'my-irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  :config
  (define-key irony-mode-map [remap completion-at-point] 'counsel-irony)
  (define-key irony-mode-map [remap complete-symbol]     'counsel-irony))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-irony
  :after (company irony)
  :config
  (add-to-list 'company-backends 'company-irony))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-irony-c-headers
  :after (company irony company-irony)
  :config
  (add-to-list 'company-backends '(company-irony-c-headers company-irony)))
#+END_SRC

***** magit
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package magit
  :demand t
  :bind
  ("C-c C-c" . with-editor-finish))
#+END_SRC

***** rainbow-delimiters
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package rainbow-delimiters
  :demand t
  :init
  (add-hook 'markdown-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'prog-mode-hook     'rainbow-delimiters-mode)
  (add-hook 'text-mode-hook     'rainbow-delimiters-mode))
#+END_SRC

***** realgud
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package realgud
  :disabled)
#+END_SRC

***** rtags
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package rtags
  :disabled
  :init
  (add-hook 'c-mode-hook    'rtags-start-process-unless-running)
  (add-hook 'c++-mode-hook  'rtags-start-process-unless-running)
  (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)

  :config
  (setq-local rtags-autostart-diagnostics         t)
  (setq-local rtags-completions-enabled           t)
  (setq-local rtags-display-result-backend        'ivy)
  (setq-local flycheck-highlighting-mode          nil)
  (setq-local flycheck-check-syntax-automatically nil)
  (rtags-diagnostics))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-rtags
  :disabled
  :after (company)
  :config
  (push 'company-rtags company-backends))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flycheck-rtags
  :disabled
  :after (rtags flycheck)
  :config
  (add-hook 'prog-mode-hook 'flycheck-mode))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ivy-rtags
  :disabled
  :config
  (setq rtags-display-result-backend 'ivy))
#+END_SRC

**** Languages
This section is gross, and due for a rewrite to explain things a bit
better.

***** General
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'lisp-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(global-visual-line-mode t)
#+END_SRC

***** Android
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package android-mode
  :disabled)
#+END_SRC

***** Angular
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package angular-mode
  :disabled)
#+END_SRC

***** Ansible
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ansible-vault)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-ansible
  :after (company ansible-vault))
#+END_SRC

***** Apache
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package apache-mode
  :disabled)
#+END_SRC

***** C
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'c-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))
            (setq-local c-default-style  "bsd")
            (setq-local c-set-style      "bsd")
            (setq-local c-basic-offset   4)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        4)))
#+END_SRC

***** C++
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'c++-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
            (setq-local c-default-style  "ellemtel")
            (setq-local c-set-style      "ellemtel")
            (setq-local c-basic-offset   4)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        4)))
#+END_SRC

***** Caddy
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package caddyfile-mode)
#+END_SRC

***** Clojure
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package clojure-mode
  :disabled
  :init
  (add-hook 'clojure-mode-hook 'flycheck-clojure 'local))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flycheck-clojure
  :disabled)
#+END_SRC

***** CMake
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package cmake-mode)
#+END_SRC

***** CoffeeScript
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package coffee-mode
  :disabled)
#+END_SRC

***** CSharp
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package csharp-mode
  :disabled)
#+END_SRC

***** Cuda
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package cuda-mode
  :disabled)
#+END_SRC

***** D
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package d-mode
  :disabled)
#+END_SRC

***** Dart
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package dart-mode
  :disabled)
#+END_SRC

***** Docker
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package docker-compose-mode)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package dockerfile-mode)
#+END_SRC

***** DotEnv
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package dotenv-mode)
#+END_SRC

***** GDScript
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package gdscript-mode
  :disabled)
#+END_SRC

***** Git
These packages provide modes that make git-related files more readable.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+END_SRC

***** Go
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(defun go-mode-install()
  "Install go-mode dependencies and log to *Messages*."
  (interactive)
  (eshell-command "go get -u -v github.com/go-delve/delve/cmd/dlv github.com/jstemmer/gotags github.com/stamblerre/gocode github.com/rogpeppe/godef golang.org/x/lint/golint golang.org/x/tools/cmd/goimports golang.org/x/tools/cmd/gorename golang.org/x/tools/cmd/guru"))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package go-mode
  :init
  (add-hook 'go-mode-hook
            (lambda()
              (add-hook 'before-save-hook 'gofmt-before-save 'local)
              (setq-local tab-width        4)
              (setq-local indent-tabs-mode t)
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode t))))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package go-eldoc
  :after (go-mode)
  :init
  (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package golint
  :after (go-mode))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-go
  :after (company go-mode))
#+END_SRC

***** Java
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package gradle-mode
  :disabled)
#+END_SRC

***** JavaScript
JavaScript is a bit of a nightmare because there are multiple competing
and not quite similar ways to write it, so clearly we need multiple
modes to choose from.  I prefer the built-in as much as possible
considering rjsx-mode is something like 30mb, and I don't really do
enough JS development to really know what the canonical mode is.

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'js-mode-hook
          (lambda()
            (setq-local js-indent-level  2)
            (setq-local indent-tabs-mode f)
            (setq-local tab-width        2)))
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package es-mode
  :disabled)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package rjsx-mode
  :disabled
  :init
  (add-to-list 'auto-mode-alist
               '("components\\/.*\\.js\\'" . rjsx-mode))

  (add-hook 'rjsx-mode
            (lambda()
              (setq-local js-indent-level 2)
              (setq-local tab-width       2))))
#+END_SRC

***** JSON
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package json-mode)
#+END_SRC

***** Less
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package less-css-mode
  :disabled)
#+END_SRC

***** Lisp
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'lisp-mode-hook
          (lambda()
            (setq-local c-basic-offset 2)
            (setq-local tab-width      2)))
#+END_SRC

***** Lua
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package lua-mode
  :disabled)
#+END_SRC

***** Markdown
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package markdown-mode)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package markdown-preview-mode
  :disabled)
#+END_SRC

***** Meson
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package meson-mode)
#+END_SRC

***** NGINX
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package nginx-mode)
#+END_SRC

***** Ninja
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ninja-mode
  :disabled)
#+END_SRC

***** Node
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package npm-mode
  :disabled)
#+END_SRC

***** Org Mode
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(add-hook 'org-mode-hook
          (lambda()
            (load-theme 'org-beautify t)
            (add-hook 'org-metaup-hook    'windmove-up    'local)
            (add-hook 'org-metaleft-hook  'windmove-left  'local)
            (add-hook 'org-metadown-hook  'windmove-down  'local)
            (add-hook 'org-metaright-hook 'windmove-right 'local)
            (setq org-support-shift-select 'always)))
#+END_SRC

***** PHP
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package php-mode)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package company-php
  :after (company php-mode))
#+END_SRC

***** Protobuf
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package protobuf-mode
  :disabled)
#+END_SRC

***** QML
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package qml-mode
  :disabled)
#+END_SRC

***** Rust
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package rust-mode)
#+END_SRC

Flycheck helper for Rust

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package flycheck-rust
  :after (rust-mode)
  :init
  (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC

***** Sass
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package sass-mode
  :disabled)
#+END_SRC

***** Swift
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package swift-mode
  :disabled)
#+END_SRC

***** systemd
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package systemd)
#+END_SRC

***** TypeScript
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package typescript-mode
  :disabled)
#+END_SRC

***** Vue
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package vue-mode
  :disabled)
#+END_SRC

Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package vue-html-mode
  :disabled)
#+END_SRC

***** Web
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package web-beautify)
#+END_SRC

***** YAML
Missing description

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package yaml-mode)
#+END_SRC

*** Extras
This section contains additional applications or packages that I
suspect others wouldn't use, though I use these rather heavily.

**** auto-dictionary
Missing description

Source: https://github.com/nschum/auto-dictionary-mode

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package auto-dictionary
  :after (flyspell)
  :config
  (add-hook 'flyspell-mode-hook (auto-dictionary-mode 1)))
#+END_SRC

**** circe
This package adds _another_ IRC client, which is my preferred client
even over irssi, weechat, or other clients I've used in the past. This
should only be situationally enabled, and is disabled by default.

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package circe
  :init
  (add-hook 'circe-message-option-functions 'my-circe-message-option-chanserv)
  (add-hook 'circe-chat-mode-hook
            (lambda()
              (lui-set-prompt
               (concat (propertize (concat (buffer-name) ":")
                                   'face 'circe-prompt-face) " "))))
  (add-hook 'lui-mode-hook
            (lambda()
              (setq fringes-outside-margins t)
              (setq left-margin-width       9)
              (setq word-wrap               t)
              (setq wrap-prefix             "")))

  :config
  (defun my-circe-message-option-chanserv (nick user host command args)
    (when (and (string= "ChanServ" nick)
               (string-match "^\\[#.+?\\]" (cadr args)))
      '((dont-display . t))))

  (setq circe-default-part-message ""
        circe-default-quit-message ""
        circe-format-server-topic  "*** Topic: {userhost}: {topic-diff}"
        circe-reduce-lurker-spam   t
        circe-use-cycle-completion t

        lui-fill-type              nil
        lui-flyspell-alist         '((".*" "american"))
        lui-flyspell-p             t
        lui-logging-directory      "~/.emacs.d/var/circe"
        lui-time-stamp-format      "%H:%M:%S"
        lui-time-stamp-position    'left-margin)

  (load "lui-logging" nil t)
  (enable-lui-logging-globally)
  (require 'circe-chanop)
  (enable-circe-color-nicks)
  (setf (cdr (assoc 'continuation fringe-indicator-alist)) nil)

  (if (file-exists-p "~/.emacs.d/usr/circe.el")
      (load-file     "~/.emacs.d/usr/circe.el")))
#+END_SRC

**** define-word
This package lets you quickly see the definition of a word or a phrase,
and is disabled by default.

Source: https://github.com/abo-abo/define-word

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package define-word
  :disabled)
#+END_SRC

**** dimmer
This package provides a minor mode which dims inactive buffers, namely
the buffers the cursor is not currently active in. It can be helpful
for those who use many buffers, though is disabled by default.

Source: https://github.com/gonewest818/dimmer.el

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package dimmer
  :init
  (add-hook 'after-init-hook 'dimmer-mode))
#+END_SRC

**** elfeed
This package provides an extensible web feed reader, supporting both
RSS and Atom.

Source: https://github.com/skeeto/elfeed

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package elfeed
  :bind ("C-x w" . elfeed)
  :config
  (setq-local elfeed-search-filter "@1-week-ago +unread ")
  (setq-local url-queue-timeout    30)
  (if (file-exists-p "~/.emacs.d/usr/elfeed.el")
      (load-file     "~/.emacs.d/usr/elfeed.el")))
#+END_SRC

**** exwm
This package provides a full-featured X tiling window manager, and is
disabled by default. I consider this to be a novelty, or a fun tech
demo, but not a viable alternative to i3wm or dwm.

Source: https://github.com/ch11ng/exwm

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package exwm
  :disabled
  :init
  (require 'exwm-config)
  (exwm-config-default)

  :config
  (global-set-key (kbd "C-c <down>")  'windmove-down)
  (global-set-key (kbd "C-c <left>")  'windmove-left)
  (global-set-key (kbd "C-c <right>") 'windmove-right)
  (global-set-key (kbd "C-c <up>")    'windmove-up))
#+END_SRC

**** helpful
This pacakge provides an alternative to the built-in Emacs help that
provides much more contextual information.

Source: https://github.com/Wilfred/helpful

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package helpful)
#+END_SRC

**** nov
This package provides a major mode for reading EPUB documents.

Source: https://github.com/wasamasa/nov.el

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package nov
  :disabled
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC

**** pdf-tools
This package allows viewing PDF's within Emacs, though in order to use
this package you must install the required dependencies and compile the
package as outlined in the following url:

https://github.com/politza/pdf-tools#installation

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package pdf-tools
  :disabled
  :config
  (pdf-loader-install))
#+END_SRC

**** ranger
This package adds a minor mode that runs within ~dired~ that emulates
much of the features provided by the ~ranger~ terminal file browser.
Hardcore ~dired~ users may want to disable this.

Source: [[https://github.com/ralesi/ranger.el]]

#+BEGIN_SRC emacs-lisp :tangle config.el
(use-package ranger
  :init
  (ranger-override-dired-mode t))
#+END_SRC
