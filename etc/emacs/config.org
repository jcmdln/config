# -*- mode: org -*-
#+TITLE:     My literate GNU/Emacs configuration
#+STARTUP:   indent
#+LANGUAGE:  en

I've attempted to maintain an Emacs configuration using various methods,
though this is an attempt to combine documentation with the actual
configuration in the most literate way possible. While this is not
exactly unique, this configuration is using org-mode and use-package to
manage the settings.

I do _NOT_ recommend directly using this configuration, though it should
serve as an adequate reference of various bits of functionality that
I've found or written over the years.


* Startup
This section comprises the things we will want to occur as soon as
possible, preferably before or during init.

** Encoding
Here we'll attempt to enforce using utf-8 encoding.

#+begin_src emacs-lisp
(setq prefer-coding-system       'utf-8
      set-default-coding-systems 'utf-8
      set-language-environment   "UTF-8"
      set-locale-environment     "en_US.UTF-8")
#+end_src

** Environment
Ensure that our Emacs environment matches our current environment. We
will modify it slightly, so that Emacs is our default editor.

#+begin_src emacs-lisp
(setenv "EDITOR"         "emacsclient")
(setenv "GIT_EDITOR"     "emacsclient")
(setenv "MANPATH"        (getenv "MANPATH"))
(setenv "PATH"           (getenv "PATH"))
(setenv "PROMPT_COMMAND" "")
(setenv "SHELL"          (getenv "SHELL"))
(setenv "TERM"           (getenv "TERM"))
#+end_src

** Adjust garbage collector percentage and threshold
First, we'll increase the gc-cons-threshold, which is the number of
bytes of storage that must be allocated for Lisp objects after one
garbage collection in order to trigger another garbage collection. On
 32-bit systems, this is 400kb and on 64-bit systems this is 800kb.
Specifying a larger value will mean that garbage collection will
occur less often.

We'll set this value to 2mb globally, which will more than halve the
total number of GC pauses we experience while not drastically
increasing the amount of time needed for GC to complete.

#+begin_src emacs-lisp
(setq gc-cons-threshold  (* 2 1024 1024))
#+end_src

For the purposes of initialization, we will also increase
gc-cons-percentage which means that until reaching 60% of the current
heap size, GC will not occur. After init completes we will set this to
15%, though the default is 10%.

#+begin_src emacs-lisp
(setq gc-cons-percentage 0.60)

(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-percentage 0.15)))
#+end_src


** Appearance
I make some minor changes to the appearance of emacs

*** Inhibit tool bars
Prevent tool bars from ever being initialized.

#+begin_src emacs-lisp
(when (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
#+end_src

*** Theme
Load the built-in tango-dark theme and use the default Monospace system
font.

#+begin_src emacs-lisp
(load-theme 'tango-dark)
(set-face-attribute :family "Monospace")
#+end_src

*** Extras
Some additional appearance or behavioral tweaks.

#+begin_src emacs-lisp
(setq custom-file                         "~/.emacs.d/custom.el"

      initial-scratch-message             ""
      inhibit-splash-screen               t
      inhibit-startup-buffer-menu         t

      column-number-mode                  t
      require-final-newline               t
      show-paren-delay                    0.0
      visible-bell                        nil

      mouse-yank-at-point                 t
      save-interprogram-paste-before-kill t
      select-enable-primary               nil)

(show-paren-mode                          t)
#+end_src


* Input
I do make some minor changes to input methods, though I intend to remain
as faithful to "the Emacs way" as I can.

** Keyboard
In terms of keyboard input, I only make slight adjustments though their
usefullness is highly subjective.

*** Scrolling
I prefer scrolling to behave more like other editors, where the cursor
reaches the final line before scrolling and the cursor scrolls one line
at a time. This does cause emacs to use additional resources, though I
prefer this behavior to the default.

#+begin_src emacs-lisp
(setq auto-window-vscroll             nil
      scroll-conservatively           101
      scroll-margin                   0
      scroll-preserve-screen-position 1
      scroll-step                     1
      scroll-up-aggressively          0.0
      scroll-down-aggressively        0.0)
#+end_src

*** Custom Keybinds
From my time of using tmux + vim I had grown to prefer some custom
keybinds I made for handling splits or navigating through panes. Here
I've attempted to recreated the subjective ease of navigation I prefer:

#+begin_src emacs-lisp
(global-set-key (kbd "M--")
                (lambda()
                  (interactive)
                  (split-window-vertically)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))

(global-set-key (kbd "M-=")
                (lambda()
                  (interactive)
                  (split-window-horizontally)
                  (other-window 1 nil)
                  (switch-to-next-buffer)))

(global-set-key (kbd "<M-down>")    'windmove-down)
(global-set-key (kbd "<M-left>")    'windmove-left)
(global-set-key (kbd "<M-right>")   'windmove-right)
(global-set-key (kbd "<M-up>")      'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)

(global-set-key (kbd "C-c c")       'comment-or-uncomment-region)
#+end_src

** Mouse
In terms of the mouse, I really only adjust scrolling behavior and add
xterm support:

#+begin_src emacs-lisp
(setq mouse-wheel-follow-mouse      't
      mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount     '(1 ((shift) . 1))
      xterm-mouse-mode              t)

(global-set-key (kbd "<mouse-4>")
                (lambda() (interactive) (scroll-down-line 3)))
(global-set-key (kbd "<mouse-5>")
                (lambda() (interactive) (scroll-up-line 3)))
#+end_src


* Package Management
In this section, we will configure the package manager to be a bit,
well, more intelligent.

First, let's require that it's loaded before we proceed:
#+begin_src emacs-lisp
(require 'package)
#+end_src

Now we'll define where packages should be installed to, then add the
archives we want to download packages from. We then set the priority
from highest to lowest based on our preference, though to clarify
further if a package exists in multiple sources, it will prefer
installing the package from the archive defined with the HIGHEST
priority. We'll then initialize package before moving on.

#+begin_src emacs-lisp
(setq package-user-dir "~/.emacs.d/pkg/"
      package-archives
      '(("GNU ELPA"     . "http://elpa.gnu.org/packages/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/"))
      package-archive-priorities
      '(("GNU ELPA"     . 1)
        ("MELPA Stable" . 2)
        ("MELPA"        . 0)))
(package-initialize)
#+end_src

Now we'll check if use-package has been installed, refresh our package
contents (ie list of known installable packages) before installing
use-package if it was missing.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+end_src

Here we'll require that use-package and bind-key are loaded AFTER they
have been byte-compiled, which will be used for loading packages and
their configurations later.

#+begin_src emacs-lisp
(eval-when-compile
  (require 'use-package)
  (require 'bind-key))
#+end_src

Before we move on, we'll make use-package have some ideal default
behaviors:
- Packages are not loaded unless called by bind, hook, or demand
- Packages are always installed if not present
- Confirm packages exist before loading configurations

#+begin_src emacs-lisp
(setq use-package-always-defer      t
      use-package-always-ensure     t
      use-package-check-before-init t)
#+end_src

Next we'll ensure that we have a clean folder hierarchy for our
configuration by using no-littering:

#+begin_src emacs-lisp
(use-package no-littering
  :demand t
  :config
  (setq-local auto-save-file-name-transforms
              `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src


* Packages
In this section we'll begin to define our packages and their
configurations, organized around their purpose into top-level sections.

** Built-ins
These are packages that Emacs currently ships with

*** eshell
The default configuration of eshell is, well, bad. The ordinary user who
opens it once and considers it to be a bad tool is missing out of the
full potential eshell provides. I've spent a _lot_ of time making eshell
behave and look like typical unix shells, so maybe try it for yourself.

#+begin_src emacs-lisp
(use-package eshell
  :config
  (setq eshell-banner-message             "")
  (setq eshell-cmpl-cycle-completions     nil)
  (setq eshell-error-if-no-glob           t)
  (setq eshell-hist-ignoredups            t)
  (setq eshell-history-size               4096)
  (setq eshell-prefer-lisp-functions      t)
  (setq eshell-save-history-on-exit       t)
  (setq eshell-scroll-to-bottom-on-input  nil)
  (setq eshell-scroll-to-bottom-on-output nil)
  (setq eshell-scroll-show-maximum-output nil)
  (setq eshell-prompt-regexp              "^[^#$\n]*[#$] ")
  (setq eshell-prompt-function
        (lambda nil
          (concat "[" (user-login-name) "@" (system-name) " "
                  (if (string= (eshell/pwd) (getenv "HOME"))
                      "~" (eshell/basename (eshell/pwd))) "]"
                  (if (= (user-uid) 0) "# " "$ "))))
  (setq eshell-visual-commands
        '("alsamixer" "atop" "htop" "less" "mosh" "nano" "ssh"
          "tail" "top" "vi" "vim" "watch"))

  (defun eshell/clear()
    (interactive)
    (recenter 0))

  (defun eshell-new()
    "Open a new instance of eshell."
    (interactive)
    (eshell 'N)))
#+end_src

*** eww
#+begin_src emacs-lisp
(use-package eww
  :init
  (setq browse-url-browser-function 'eww-browse-url)
  :config
  (setq shr-blocked-images "")

  (defun eww-toggle-images()
    "Toggle blocking images in eww."
    (interactive)
    (if (bound-and-true-p shr-blocked-images)
        (setq-local shr-blocked-images nil)
      (setq-local shr-blocked-images ""))
    (eww-reload))

  (defun eww-new()
    "Open a new instance of eww."
    (interactive)
    (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
      (switch-to-buffer (generate-new-buffer "*eww*"))
      (eww-mode)
      (eww url))))
#+end_src

*** eww-lnum
#+begin_src emacs-lisp
(use-package eww-lnum
  :after (eww)
  :init
  (add-hook 'eww-mode-hook
            (lambda()
              (define-key eww-mode-map "f" 'eww-lnum-follow)
              (define-key eww-mode-map "F" 'eww-lnum-universal))))
#+end_src

*** gnus
#+begin_src emacs-lisp
(use-package gnus
  :bind (("<M-down>" . windmove-down)
         ("<M-up>"   . windmove-up))
  :init
  (add-hook 'gnus-summary-hook   'gnus-summary-sort-by-most-recent-date)

  :config
  (setq-default gnus-sum-thread-tree-false-root        "")
  (setq-default gnus-sum-thread-tree-indent            "  ")
  (setq-default gnus-sum-thread-tree-leaf-with-other   "├─> ")
  (setq-default gnus-sum-thread-tree-root              "")
  (setq-default gnus-sum-thread-tree-single-leaf       "╰─> ")
  (setq-default gnus-sum-thread-tree-vertical          "│ ")

  (setq-default gnus-summary-line-format               "%U%R:%-15,15o  %-15,15f  %B%S\n")
  (setq-default gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)
  (setq-default gnus-thread-sort-functions             '(gnus-thread-sort-by-date))

  (if (file-exists-p  "~/.emacs.d/usr/gnus.el")
      (load-file      "~/.emacs.d/usr/gnus.el")))
#+end_src

*** ibuffer
#+begin_src emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b"         . ibuffer)
         ("<C-tab>"         . next-buffer)
         ("<C-iso-lefttab>" . previous-buffer))

  :init
  (add-hook 'ibuffer-hook      'ibuffer-auto-mode)
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-alphabetic)
  (add-hook 'ibuffer-auto-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  :config
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))

  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("emacs"
                  (or (name . "^\\*scratch\\*$")
                      (name . "^\\*Messages\\*$")
                      (name . "^\\*Completions\\*$")
                      (name . "^\\*Help\\*$")
                      (name . "^\\*Disabled Command\\*$")
                      (mode . dired-mode)))

                 ("circe"
                  (or (mode . circe-mode)
                      (mode . circe-channel-mode)
                      (mode . circe-server-mode)))

                 ("clang"  (name . "^\\*clang-"))
                 ("dev"    (name . "^\\*RTags\\*$"))
                 ("elfeed" (name . "^\\*elfeed"))
                 ("eshell" (mode . eshell-mode))
                 ("eww"    (name . "^\\*eww\\*"))

                 ("fly"
                  (or (name . "^\\*Flycheck")
                      (name . "^\\*Flyspell")))

                 ("gnus"
                  (or (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))

                 ("magit"
                  (or (name . "magit")
                      (name . "COMMIT_EDITMSG")))

                 ("man"
                  (or (name . "^\\*Man ")
                      (name . "^\\*WoMan")))))))

  (setq ibuffer-formats
        '((mark modified read-only " "
                (name 35 35 :left :nil) " "
                (size-h 9 -1 :right) " "
                (mode 16 16 :left :elide) " "
                filename-and-process))))
#+end_src

*** scratch
#+begin_src emacs-lisp
(use-package scratch
  :init
  (defun scratch-new()
    "Open a new scratch buffer."
    (interactive)
    (switch-to-buffer (generate-new-buffer "*scratch*"))
    (lisp-mode)))
#+end_src

*** server
#+begin_src emacs-lisp
(use-package server
  :bind ("C-x C-c" . server-stop)
  :config
  (unless (server-running-p)(server-start))

  (defun server-kill()
    "Delete current Emacs server, then kill Emacs"
    (interactive)
    (if (y-or-n-p "Kill Emacs without saving? ")
        (kill-emacs)))

  (defun server-stop()
    "Prompt to save buffers, then kill Emacs."
    (interactive)
    (if (y-or-n-p "Quit Emacs? ")
        (save-buffers-kill-emacs)))

  (defun server-update()
    "Refresh package contents, then update all packages."
    (interactive)
    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))
    (package-utils-upgrade-all)))
#+end_src


** Essentials
This section contains packages that integrate well with emacs while
extending the default behaviors. These packages, much like the title
implies, are essential for me.

*** async
#+begin_src emacs-lisp
(use-package async
  :config (async-bytecomp-package-mode '(all)))
#+end_src

*** auto-compile
#+begin_src emacs-lisp
(use-package auto-compile
  :config
  (auto-compile-on-load-mode)
  (auto-compile-on-save-mode))
#+end_src

*** counsel
#+begin_src emacs-lisp
(use-package counsel
  :bind (("<f1> f"  . counsel-describe-function)
         ("<f1> l"  . counsel-find-library)
         ("<f1> v"  . counsel-describe-variable)
         ("<f2> i"  . counsel-info-lookup-symbol)
         ("<f2> u"  . counsel-unicode-char)
         ("C-S-o"   . counsel-rhythmbox)
         ("C-c g"   . counsel-git)
         ("C-c j"   . counsel-git-grep)
         ("C-c l"   . counsel-ag)
         ("C-r"     . counsel-minibuffer-history)
         ("C-x C-f" . counsel-find-file)
         ("C-x l"   . counsel-locate)
         ("M-x"     . counsel-M-x)))

(use-package counsel-etags
  :init
  (add-hook 'c-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))

  (add-hook 'c++-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))

  :config
  (setq-local large-file-warning-threshold nil)
  (setq-local tags-revert-without-query    t))
#+end_src

*** flyspell
#+begin_src emacs-lisp
(use-package flyspell
  :init
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'prog-mode-hook     'flyspell-prog-mode)
  (add-hook 'text-mode-hook     'flyspell-mode))
#+end_src

*** ivy
#+begin_src emacs-lisp
(use-package ivy
  :bind (("C-c C-r" . ivy-resume)
         ("<f6>"    . ivy-resume))

  :init
  (ivy-mode 1)

  :config
  (setq ivy-use-virtual-buffers      t)
  (setq enable-recursive-minibuffers t))
#+end_src

*** package-utils
#+begin_src emacs-lisp
(use-package package-utils
  :demand t)
#+end_src

*** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :demand t
  :init
  (add-hook 'markdown-mode-hook 'smartparens-mode)
  (add-hook 'prog-mode-hook     'smartparens-mode)
  (add-hook 'text-mode-hook     'smartparens-mode)

  :config
  (setq sp-highlight-pair-overlay     nil)
  (setq sp-highlight-wrap-overlay     nil)
  (setq sp-highlight-wrap-tag-overlay nil))
#+end_src

*** swiper
#+begin_src emacs-lisp
(use-package swiper
  :demand t
  :bind ("C-s" . swiper))
#+end_src

*** undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :demand t
  :config (global-undo-tree-mode))
#+end_src

*** xclip
#+begin_src emacs-lisp
(use-package xclip
  :config (xclip-mode 1))
#+end_src


** Development
This section contains packages that are primarily used for development.
If you aren't using Emacs for development, this sction will not be very
useful for you.

Before we continue to individual packages, first we'll change some
default behaviors so that tabs aren't used, trailing whitespace is
deleted, and on save all tabs are replaced with spaces.

#+begin_src emacs-lisp
(setq indent-tabs-mode nil)

(add-hook 'before-save-hook
          (lambda()
            (delete-trailing-whitespace)
            (if (not indent-tabs-mode)
                (untabify (point-min) (point-max)))))
#+end_src

*** company
#+begin_src emacs-lisp
(use-package company
  :init
  (add-hook 'lisp-mode-hook 'company-mode)
  (add-hook 'prog-mode-hook 'company-mode)
  (add-hook 'text-mode-hook 'company-mode)

  :config
  (setq company-tooltip-limit  20)
  (setq company-idle-delay     0.3)
  (setq company-echo-delay     0)
  (setq company-begin-commands '(self-insert-command)))

(use-package company-ansible
  :after (company ansible-vault))

(use-package company-emoji
  :after (company))

(use-package company-go
  :after (company))

(use-package company-irony
  :after (company irony)
  :config
  (add-to-list 'company-backends 'company-irony))

(use-package company-irony-c-headers
  :after (company irony company-irony)
  :config
  (add-to-list 'company-backends '(company-irony-c-headers company-irony)))

(use-package company-php
  :after (company php-mode))

(use-package company-shell
  :after (company))

(use-package company-web
  :after (company))
#+end_src

*** diff-hl
#+begin_src emacs-lisp
(use-package diff-hl
  :init
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'text-mode-hook 'diff-hl-mode))
#+end_src

*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :demand t
  :init
  (add-hook 'prog-mode-hook 'flycheck-mode))

(use-package flycheck-inline
  :demand t
  :init
  (add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))

(use-package flycheck-clojure)
#+end_src

*** gist
#+begin_src emacs-lisp
(use-package gist)
#+end_src

*** highlight-indent-guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :demand t
  :init
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
  :config
  (setq highlight-indent-guides-method 'character))
#+end_src

*** irony
#+begin_src emacs-lisp
(use-package irony
  :init
  (defun my-irony-mode ()
    (when (memq major-mode '(c-mode c++-mode objc-mode))
      (irony-mode 1)))

  (add-hook 'c-mode-hook   'my-irony-mode)
  (add-hook 'c++-mode-hook 'my-irony-mode)
  (add-hook 'objc-mode     'my-irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  :config
  (define-key irony-mode-map [remap completion-at-point] 'counsel-irony)
  (define-key irony-mode-map [remap complete-symbol]     'counsel-irony))
#+end_src

*** languages
#+begin_src emacs-lisp
(add-hook 'lisp-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(global-visual-line-mode t)

(add-hook 'c-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))
            (setq-local c-default-style  "linux")
            (setq-local c-set-style      "linux")
            (setq-local c-basic-offset   8)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        8)))

(add-hook 'c++-mode-hook
          (lambda()
            (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
            (setq-local c-default-style  "ellemtel")
            (setq-local c-set-style      "ellemtel")
            (setq-local c-basic-offset   4)
            (setq-local indent-tabs-mode t)
            (setq-local tab-width        2)))

(add-hook 'lisp-mode
          (lambda()
            (setq-local c-basic-offset 2)
            (setq-local tab-width      2)))

(use-package ahk-mode)
(use-package android-mode)
(use-package angular-mode)
(use-package ansible-vault)
(use-package apache-mode)
(use-package caddyfile-mode)

(use-package clojure-mode
  :init
  (add-hook 'clojure-mode-hook 'flycheck-clojure))

(use-package cmake-mode)
(use-package coffee-mode)
(use-package csharp-mode)
(use-package cuda-mode)
(use-package d-mode)
(use-package dart-mode)
(use-package docker-compose-mode)
(use-package dockerfile-mode)
(use-package dotenv-mode)
(use-package es-mode)
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)

(use-package go-mode
  :init
  (add-hook 'before-save-hook 'gofmt-before-save)
  (add-hook 'go-mode-hook
            (lambda()
              (setq-local tab-width        4)
              (setq-local indent-tabs-mode t)
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode t))))

(use-package gradle-mode)
(use-package json-mode)
(use-package less-css-mode)
(use-package lua-mode)
(use-package markdown-mode)
(use-package markdown-preview-mode)
(use-package meson-mode)
(use-package nginx-mode)
(use-package ninja-mode)
(use-package npm-mode)
(use-package php-mode)
(use-package protobuf-mode)
(use-package qml-mode)
(use-package racket-mode)

(use-package rjsx-mode
  :init
  (add-to-list 'auto-mode-alist
               '("components\\/.*\\.js\\'" . rjsx-mode))
  (add-hook 'rjsx-mode
            (lambda()
              (setq-local indent-tabs-mode nil)
              (setq-local tab-width        2))))

(use-package rust-mode)
(use-package sass-mode)
(use-package swift-mode)
(use-package systemd)
(use-package typescript-mode)
(use-package vue-mode)
(use-package yaml-mode)
#+end_src

*** magit
#+begin_src emacs-lisp
(use-package magit
  :bind ("C-c C-c" . with-editor-finish)
  :demand t)
#+end_src

*** rainbow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :demand t
  :init
  (add-hook 'markdown-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'prog-mode-hook     'rainbow-delimiters-mode)
  (add-hook 'text-mode-hook     'rainbow-delimiters-mode))
#+end_src

*** realgud
#+begin_src emacs-lisp
(use-package realgud)
#+end_src


** Extras
This section contains additional applications or packages that I
suspect others wouldn't use, though I use these rather heavily.

*** auto-dictionary
#+begin_src emacs-lisp
(use-package auto-dictionary
  :config
  (add-hook 'flyspell-mode-hook (auto-dictionary-mode 1)))
#+end_src

*** circe
#+begin_src emacs-lisp
(use-package circe
  :init
  (add-hook 'circe-message-option-functions 'my-circe-message-option-chanserv)
  (add-hook 'circe-chat-mode-hook
            (lambda()
              (lui-set-prompt
               (concat (propertize (concat (buffer-name) ":")
                                   'face 'circe-prompt-face) " "))))
  (add-hook 'lui-mode-hook
            (lambda()
              (setq-local fringes-outside-margins t)
              (setq-local left-margin-width       9)
              (setq-local word-wrap               t)
              (setq-local wrap-prefix             "")))

  :config
  (defun my-circe-message-option-chanserv (nick user host command args)
    (when (and (string= "ChanServ" nick)
               (string-match "^\\[#.+?\\]" (cadr args)))
      '((dont-display . t))))

  (setq-local circe-default-part-message "")
  (setq-local circe-default-quit-message "")
  (setq-local circe-format-server-topic  "*** Topic: {userhost}: {topic-diff}")
  (setq-local circe-reduce-lurker-spam   t)
  (setq-local circe-use-cycle-completion t)
  (setq-local lui-fill-type              nil)
  (setq-local lui-flyspell-alist         '((".*" "american")))
  (setq-local lui-flyspell-p             t)
  (setq-local lui-logging-directory      "~/.emacs.d/var/circe")
  (setq-local lui-time-stamp-format      "%H:%M:%S")
  (setq-local lui-time-stamp-position    'left-margin)

  (load "lui-logging" nil t)
  (enable-lui-logging-globally)
  (require 'circe-chanop)
  (enable-circe-color-nicks)
  (setf (cdr (assoc 'continuation fringe-indicator-alist)) nil)

  (if (file-exists-p "~/.emacs.d/usr/circe.el")
      (load-file     "~/.emacs.d/usr/circe.el")))
#+end_src

*** define-word
#+begin_src emacs-lisp
(use-package define-word)
#+end_src

*** dimmer
#+begin_src emacs-lisp
(use-package dimmer
  :init
  (add-hook 'after-init-hook 'dimmer-mode))
#+end_src

*** elfeed
#+begin_src emacs-lisp
(use-package elfeed
  :bind ("C-x w" . elfeed)

  :config
  (setq-local elfeed-search-filter "@1-week-ago +unread ")
  (setq-local url-queue-timeout    30)

  (if (file-exists-p  "~/.emacs.d/usr/elfeed.el")
      (load-file      "~/.emacs.d/usr/elfeed.el")))
#+end_src

*** helpful
#+begin_src emacs-lisp
(use-package helpful)
#+end_src

*** nov
#+begin_src emacs-lisp
(use-package nov
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src

*** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :demand t)
#+end_src

*** ranger
#+begin_src emacs-lisp
(use-package ranger
  :init
  (ranger-override-dired-mode t))
#+end_src
